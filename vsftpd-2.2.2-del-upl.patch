From d04be35193b30f94b56a956061d017f3103886d0 Mon Sep 17 00:00:00 2001
From: Martin Sehnoutka <msehnout@redhat.com>
Date: Tue, 17 Jan 2017 17:59:27 +0100
Subject: [PATCH] Bug 894340 and 1411415

The vsftpd doesn't remove failed upload when the delete_failed_uploads
is enabled and the network cable is unplagged.
vsftpd-2.2.2-21.el6 not responding with '421 Timeout.' like previous
vsftpd versions in RHEL 6
---
 ftpcmdio.c  | 31 ++++++++++++++++++++++++++-----
 ftpcodes.h  |  3 ++-
 ftpdataio.c | 35 ++++++++++++++++++++++++++++-------
 main.c      |  4 ++--
 netstr.c    |  4 ++--
 postlogin.c | 43 ++++++++++++++++++++++++++++++++++---------
 session.h   |  3 +++
 sysutil.c   | 10 ++++++++++
 sysutil.h   |  1 +
 9 files changed, 108 insertions(+), 26 deletions(-)

diff --git a/ftpcmdio.c b/ftpcmdio.c
index 08a2548..475e6e8 100644
--- a/ftpcmdio.c
+++ b/ftpcmdio.c
@@ -21,7 +21,7 @@
 #include "readwrite.h"
 
 /* Internal functions */
-static void control_getline(struct mystr* p_str, struct vsf_session* p_sess);
+static int control_getline(struct mystr* p_str, struct vsf_session* p_sess);
 static void ftp_write_text_common(struct vsf_session* p_sess, int status,
                                   const char* p_text, int noblock, char sep);
 static void ftp_write_str_common(struct vsf_session* p_sess, int status,
@@ -41,7 +41,9 @@ static void
 handle_alarm_timeout(void* p_private)
 {
   struct vsf_session* p_sess = (struct vsf_session*) p_private;
-  vsf_cmdio_write_exit(p_sess, FTP_IDLE_TIMEOUT, "Timeout.");
+  p_sess->idle_timeout = 1;
+  vsf_sysutil_activate_noblock(VSFTP_COMMAND_FD);
+  vsf_sysutil_shutdown_read_failok(VSFTP_COMMAND_FD);
 }
 
 void
@@ -81,6 +83,7 @@ vsf_cmdio_write_exit(struct vsf_session* p_sess, int status, const char* p_text)
    * connections, where the SSL control channel slave is in a separate
    * process.
    */
+  vsf_sysutil_activate_noblock(VSFTP_COMMAND_FD);
   vsf_sysutil_shutdown_read_failok(VSFTP_COMMAND_FD);
   ftp_write_text_common(p_sess, status, p_text, 1, ' ');
   vsf_sysutil_shutdown_failok(VSFTP_COMMAND_FD);
@@ -168,13 +171,26 @@ void
 vsf_cmdio_get_cmd_and_arg(struct vsf_session* p_sess, struct mystr* p_cmd_str,
                           struct mystr* p_arg_str, int set_alarm)
 {
+  int ret;
   /* Prepare an alarm to timeout the session.. */
   if (set_alarm)
   {
     vsf_cmdio_set_alarm(p_sess);
   }
   /* Blocks */
-  control_getline(p_cmd_str, p_sess);
+  ret = control_getline(p_cmd_str, p_sess);
+  if (p_sess->idle_timeout)
+  {
+    vsf_cmdio_write_exit(p_sess, FTP_IDLE_TIMEOUT, "Timeout.");
+  }
+  if (ret == 0)
+  {
+    /* Remote end hung up without a polite QUIT. The shutdown is to make
+     * sure buggy clients don't ever see an OOPS message.
+     */
+    vsf_sysutil_shutdown_failok(VSFTP_COMMAND_FD);
+    vsf_sysutil_exit(1);
+  }
   /* View a single space as a command of " ", which although a useless command,
    * permits the caller to distinguish input of "" from " ".
    */
@@ -207,7 +223,7 @@ vsf_cmdio_get_cmd_and_arg(struct vsf_session* p_sess, struct mystr* p_cmd_str,
   }
 }
 
-static void
+static int
 control_getline(struct mystr* p_str, struct vsf_session* p_sess)
 {
   int ret;
@@ -216,7 +232,11 @@ control_getline(struct mystr* p_str, struct vsf_session* p_sess)
     vsf_secbuf_alloc(&p_sess->p_control_line_buf, VSFTP_MAX_COMMAND_LINE);
   }
   ret = ftp_getline(p_sess, p_str, p_sess->p_control_line_buf);
-  if (ret < 0)
+  if (ret == 0)
+  {
+    return ret;
+  }
+  else if (ret < 0)
   {
     vsf_cmdio_write_exit(p_sess, FTP_BADCMD, "Input line too long.");
   }
@@ -231,5 +251,6 @@ control_getline(struct mystr* p_str, struct vsf_session* p_sess)
       --len;
     }
   }
+  return 1;
 }
 
diff --git a/ftpcodes.h b/ftpcodes.h
index 93290c0..995788a 100644
--- a/ftpcodes.h
+++ b/ftpcodes.h
@@ -15,7 +15,8 @@
 #define FTP_PBSZOK            200
 #define FTP_PROTOK            200
 #define FTP_OPTSOK            200
-#define FTP_ALLOOK            202
+#define FTP_ALLOOK            200
+#define FTP_ALLOIGN           202
 #define FTP_FEAT              211
 #define FTP_STATOK            211
 #define FTP_SIZEOK            213
diff --git a/ftpdataio.c b/ftpdataio.c
index 72a1edc..f00044b 100644
--- a/ftpdataio.c
+++ b/ftpdataio.c
@@ -61,8 +61,6 @@ vsf_ftpdataio_dispose_transfer_fd(struct vsf_session* p_sess)
   {
     bug("no data descriptor in vsf_ftpdataio_dispose_transfer_fd");
   }
-  /* Reset the data connection alarm so it runs anew with the blocking close */
-  start_data_alarm(p_sess);
   vsf_sysutil_uninstall_io_handler();
   if (p_sess->data_use_ssl && p_sess->ssl_slave_active)
   {
@@ -76,8 +74,17 @@ vsf_ftpdataio_dispose_transfer_fd(struct vsf_session* p_sess)
   }
   else if (p_sess->p_data_ssl)
   {
+    start_data_alarm(p_sess);
     dispose_ret = ssl_data_close(p_sess);
   }
+  if (!p_sess->abor_received && !p_sess->data_timeout && dispose_ret == 1)
+  {
+    /* If we didn't get a failure, linger on the close() in order to get more
+     * accurate transfer times.
+     */
+    start_data_alarm(p_sess);
+    vsf_sysutil_activate_linger(p_sess->data_fd);
+  }
   /* This close() blocks because we set SO_LINGER */
   retval = vsf_sysutil_close_failok(p_sess->data_fd);
   if (vsf_sysutil_retval_is_error(retval))
@@ -86,11 +93,15 @@ vsf_ftpdataio_dispose_transfer_fd(struct vsf_session* p_sess)
     vsf_sysutil_deactivate_linger_failok(p_sess->data_fd);
     (void) vsf_sysutil_close_failok(p_sess->data_fd);
   }
+  p_sess->data_fd = -1;
   if (tunable_data_connection_timeout > 0)
   {
     vsf_sysutil_clear_alarm();
   }
-  p_sess->data_fd = -1;
+  if (p_sess->abor_received || p_sess->data_timeout)
+  {
+    dispose_ret = 0;
+  }
   return dispose_ret;
 }
 
@@ -189,11 +200,13 @@ handle_sigalrm(void* p_private)
   struct vsf_session* p_sess = (struct vsf_session*) p_private;
   if (!p_sess->data_progress)
   {
-    vsf_cmdio_write_exit(p_sess, FTP_DATA_TIMEOUT,
-                         "Data timeout. Reconnect. Sorry.");
+    p_sess->data_timeout = 1;
+    vsf_sysutil_shutdown_failok(p_sess->data_fd);
+    vsf_sysutil_shutdown_read_failok(VSFTP_COMMAND_FD);
+  } else {
+    p_sess->data_progress = 0;
+    start_data_alarm(p_sess);
   }
-  p_sess->data_progress = 0;
-  start_data_alarm(p_sess);
 }
 
 void
@@ -232,6 +245,10 @@ init_data_sock_params(struct vsf_session* p_sess, int sock_fd)
   /* Start the timeout monitor */
   vsf_sysutil_install_io_handler(handle_io, p_sess);
   start_data_alarm(p_sess);
+  if(tunable_delete_failed_uploads)
+  {
+    vsf_sysutil_rcvtimeo(sock_fd);
+  }
 }
 
 static void
@@ -604,6 +621,10 @@ do_file_recv(struct vsf_session* p_sess, int file_fd, int is_ascii)
     else if (retval == 0 && !prev_cr)
     {
       /* Transfer done, nifty */
+      if (tunable_delete_failed_uploads &&
+          !is_ascii && p_sess->upload_size > 0 &&
+          p_sess->upload_size != ret_struct.transferred)
+        ret_struct.retval = -2;
       return ret_struct;
     }
     num_to_write = (unsigned int) retval;
diff --git a/main.c b/main.c
index 2aa18c0..c44e373 100644
--- a/main.c
+++ b/main.c
@@ -38,13 +38,13 @@ main(int argc, const char* argv[])
   struct vsf_session the_session =
   {
     /* Control connection */
-    0, 0, 0,
+    0, 0, 0, 0, 0,
     /* Data connection */
     -1, 0, -1, 0, 0, 0, 0, 0,
     /* Login */
     1, 0, INIT_MYSTR, INIT_MYSTR,
     /* Protocol state */
-    0, 1, INIT_MYSTR, 0, 0,
+    0, 0, 1, INIT_MYSTR, 0, 0,
     /* Session state */
     0,
     /* Userids */
diff --git a/netstr.c b/netstr.c
index 2e4930b..6541dcd 100644
--- a/netstr.c
+++ b/netstr.c
@@ -29,6 +29,7 @@ str_netfd_alloc(struct vsf_session* p_sess,
   unsigned int i;
   char* p_readpos = p_readbuf;
   unsigned int left = maxlen;
+  str_empty(p_str);
   while (1)
   {
     if (p_readpos + left != p_readbuf + maxlen)
@@ -38,7 +39,6 @@ str_netfd_alloc(struct vsf_session* p_sess,
     /* Did we hit the max? */
     if (left == 0)
     {
-      str_empty(p_str);
       return -1;
     }
     retval = (*p_peekfunc)(p_sess, p_readpos, left);
@@ -48,7 +48,7 @@ str_netfd_alloc(struct vsf_session* p_sess,
     }
     else if (retval == 0)
     {
-      die("vsf_sysutil_recv_peek: no data");
+      return 0;
     }
     bytes_read = (unsigned int) retval;
     /* Search for the terminator */
diff --git a/postlogin.c b/postlogin.c
index 92ed76f..e1f080f 100644
--- a/postlogin.c
+++ b/postlogin.c
@@ -344,7 +344,15 @@ process_post_login(struct vsf_session* p_sess)
     }
     else if (str_equal_text(&p_sess->ftp_cmd_str, "ALLO"))
     {
-      vsf_cmdio_write(p_sess, FTP_ALLOOK, "ALLO command ignored.");
+      if (tunable_delete_failed_uploads && !p_sess->is_ascii)
+      {
+        
+        p_sess->upload_size = (filesize_t)vsf_sysutil_atoi(str_getbuf(&p_sess->ftp_cmd_str)+5);
+        vsf_cmdio_write(p_sess, FTP_ALLOOK, "The filesize has been allocated.");
+      }
+      else {
+        vsf_cmdio_write(p_sess, FTP_ALLOIGN, "ALLO command ignored.");
+      }
     }
     else if (str_equal_text(&p_sess->ftp_cmd_str, "REIN"))
     {
@@ -435,6 +443,11 @@ process_post_login(struct vsf_session* p_sess)
     {
       vsf_log_do_log(p_sess, 0);
     }
+    if (p_sess->data_timeout)
+    {
+      vsf_cmdio_write_exit(p_sess, FTP_DATA_TIMEOUT,
+                           "Data timeout. Reconnect. Sorry.");
+    }
   }
 }
 
@@ -734,7 +747,11 @@ handle_retr(struct vsf_session* p_sess)
   }
   else if (trans_ret.retval == -2)
   {
-    vsf_cmdio_write(p_sess, FTP_BADSENDNET, "Failure writing network stream.");
+    if (!p_sess->data_timeout)
+    {
+      vsf_cmdio_write(p_sess, FTP_BADSENDNET,
+                      "Failure writing network stream.");
+    }
   }
   else
   {
@@ -872,18 +889,22 @@ handle_dir_common(struct vsf_session* p_sess, int full_details, int stat_cmd)
   {
     vsf_cmdio_write(p_sess, FTP_STATFILE_OK, "End of status");
   }
+  else if (retval != 0)
+  {
+    if (!p_sess->data_timeout)
+    {
+      vsf_cmdio_write(p_sess, FTP_BADSENDNET,
+                      "Failure writing network stream.");
+    }
+  }
   else if (p_dir == 0 || !dir_allow_read)
   {
     vsf_cmdio_write(p_sess, FTP_TRANSFEROK,
                     "Transfer done (but failed to open directory).");
   }
-  else if (retval == 0)
-  {
-    vsf_cmdio_write(p_sess, FTP_TRANSFEROK, "Directory send OK.");
-  }
   else
   {
-    vsf_cmdio_write(p_sess, FTP_BADSENDNET, "Failure writing network stream.");
+    vsf_cmdio_write(p_sess, FTP_TRANSFEROK, "Directory send OK.");
   }
   check_abor(p_sess);
 dir_close_out:
@@ -1103,9 +1124,13 @@ handle_upload_common(struct vsf_session* p_sess, int is_append, int is_unique)
   {
     vsf_cmdio_write(p_sess, FTP_BADSENDFILE, "Failure writing to local file.");
   }
-  else if (trans_ret.retval == -2 || p_sess->abor_received)
+  else if (trans_ret.retval == -2)
   {
-    vsf_cmdio_write(p_sess, FTP_BADSENDNET, "Failure reading network stream.");
+    if (!p_sess->data_timeout)
+    {
+      vsf_cmdio_write(p_sess, FTP_BADSENDNET,
+                      "Failure reading network stream.");
+    }
   }
   else
   {
diff --git a/session.h b/session.h
index 4adf336..f9bd4c4 100644
--- a/session.h
+++ b/session.h
@@ -21,6 +21,8 @@ struct vsf_session
   struct vsf_sysutil_sockaddr* p_local_addr;
   struct vsf_sysutil_sockaddr* p_remote_addr;
   char* p_control_line_buf;
+  int idle_timeout;
+  int data_timeout;
 
   /* Details of the data connection */
   int pasv_listen_fd;
@@ -39,6 +41,7 @@ struct vsf_session
   struct mystr anon_pass_str;
 
   /* Details of the FTP protocol state */
+  filesize_t upload_size;
   filesize_t restart_pos;
   int is_ascii;
   struct mystr rnfr_filename_str;
diff --git a/sysutil.c b/sysutil.c
index 02d9a6c..01a726d 100644
--- a/sysutil.c
+++ b/sysutil.c
@@ -682,6 +682,16 @@ vsf_sysutil_activate_keepalive(int fd)
 }
 
 void
+vsf_sysutil_rcvtimeo(int fd)
+{
+  struct timeval tv;
+
+  tv.tv_sec = tunable_data_connection_timeout;
+  tv.tv_usec = 0;
+  setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(struct timeval));
+}
+
+void
 vsf_sysutil_activate_reuseaddr(int fd)
 {
   int reuseaddr = 1;
diff --git a/sysutil.h b/sysutil.h
index b951d0e..92fb7a9 100644
--- a/sysutil.h
+++ b/sysutil.h
@@ -266,6 +266,7 @@ void vsf_sysutil_dns_resolve(struct vsf_sysutil_sockaddr** p_sockptr,
 /* Option setting on sockets */
 void vsf_sysutil_v6only(int fd);
 void vsf_sysutil_activate_keepalive(int fd);
+void vsf_sysutil_rcvtimeo(int fd);
 void vsf_sysutil_set_iptos_throughput(int fd);
 void vsf_sysutil_activate_reuseaddr(int fd);
 void vsf_sysutil_set_nodelay(int fd);
-- 
2.9.3

